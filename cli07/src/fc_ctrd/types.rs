// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.ExtraData)
pub struct ExtraData {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.ExtraData.JsonSpec)
    pub JsonSpec: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:fc_ctrd.ExtraData.RuncOptions)
    pub RuncOptions: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // @@protoc_insertion_point(field:fc_ctrd.ExtraData.StdinPort)
    pub StdinPort: u32,
    // @@protoc_insertion_point(field:fc_ctrd.ExtraData.StdoutPort)
    pub StdoutPort: u32,
    // @@protoc_insertion_point(field:fc_ctrd.ExtraData.StderrPort)
    pub StderrPort: u32,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.ExtraData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtraData {
    fn default() -> &'a ExtraData {
        <ExtraData as ::protobuf::Message>::default_instance()
    }
}

impl ExtraData {
    pub fn new() -> ExtraData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "JsonSpec",
            |m: &ExtraData| { &m.JsonSpec },
            |m: &mut ExtraData| { &mut m.JsonSpec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "RuncOptions",
            |m: &ExtraData| { &m.RuncOptions },
            |m: &mut ExtraData| { &mut m.RuncOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StdinPort",
            |m: &ExtraData| { &m.StdinPort },
            |m: &mut ExtraData| { &mut m.StdinPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StdoutPort",
            |m: &ExtraData| { &m.StdoutPort },
            |m: &mut ExtraData| { &mut m.StdoutPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StderrPort",
            |m: &ExtraData| { &m.StderrPort },
            |m: &mut ExtraData| { &mut m.StderrPort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtraData>(
            "ExtraData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtraData {
    const NAME: &'static str = "ExtraData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.JsonSpec = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.RuncOptions)?;
                },
                24 => {
                    self.StdinPort = is.read_uint32()?;
                },
                32 => {
                    self.StdoutPort = is.read_uint32()?;
                },
                40 => {
                    self.StderrPort = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.JsonSpec.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.JsonSpec);
        }
        if let Some(v) = self.RuncOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.StdinPort != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.StdinPort);
        }
        if self.StdoutPort != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.StdoutPort);
        }
        if self.StderrPort != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.StderrPort);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.JsonSpec.is_empty() {
            os.write_bytes(1, &self.JsonSpec)?;
        }
        if let Some(v) = self.RuncOptions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.StdinPort != 0 {
            os.write_uint32(3, self.StdinPort)?;
        }
        if self.StdoutPort != 0 {
            os.write_uint32(4, self.StdoutPort)?;
        }
        if self.StderrPort != 0 {
            os.write_uint32(5, self.StderrPort)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtraData {
        ExtraData::new()
    }

    fn clear(&mut self) {
        self.JsonSpec.clear();
        self.RuncOptions.clear();
        self.StdinPort = 0;
        self.StdoutPort = 0;
        self.StderrPort = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtraData {
        static instance: ExtraData = ExtraData {
            JsonSpec: ::std::vec::Vec::new(),
            RuncOptions: ::protobuf::MessageField::none(),
            StdinPort: 0,
            StdoutPort: 0,
            StderrPort: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtraData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtraData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtraData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerNetworkInterface)
pub struct FirecrackerNetworkInterface {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerNetworkInterface.AllowMMDS)
    pub AllowMMDS: bool,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerNetworkInterface.InRateLimiter)
    pub InRateLimiter: ::protobuf::MessageField<FirecrackerRateLimiter>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerNetworkInterface.OutRateLimiter)
    pub OutRateLimiter: ::protobuf::MessageField<FirecrackerRateLimiter>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerNetworkInterface.CNIConfig)
    pub CNIConfig: ::protobuf::MessageField<CNIConfiguration>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerNetworkInterface.StaticConfig)
    pub StaticConfig: ::protobuf::MessageField<StaticNetworkConfiguration>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerNetworkInterface.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerNetworkInterface {
    fn default() -> &'a FirecrackerNetworkInterface {
        <FirecrackerNetworkInterface as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerNetworkInterface {
    pub fn new() -> FirecrackerNetworkInterface {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AllowMMDS",
            |m: &FirecrackerNetworkInterface| { &m.AllowMMDS },
            |m: &mut FirecrackerNetworkInterface| { &mut m.AllowMMDS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FirecrackerRateLimiter>(
            "InRateLimiter",
            |m: &FirecrackerNetworkInterface| { &m.InRateLimiter },
            |m: &mut FirecrackerNetworkInterface| { &mut m.InRateLimiter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FirecrackerRateLimiter>(
            "OutRateLimiter",
            |m: &FirecrackerNetworkInterface| { &m.OutRateLimiter },
            |m: &mut FirecrackerNetworkInterface| { &mut m.OutRateLimiter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CNIConfiguration>(
            "CNIConfig",
            |m: &FirecrackerNetworkInterface| { &m.CNIConfig },
            |m: &mut FirecrackerNetworkInterface| { &mut m.CNIConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StaticNetworkConfiguration>(
            "StaticConfig",
            |m: &FirecrackerNetworkInterface| { &m.StaticConfig },
            |m: &mut FirecrackerNetworkInterface| { &mut m.StaticConfig },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerNetworkInterface>(
            "FirecrackerNetworkInterface",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerNetworkInterface {
    const NAME: &'static str = "FirecrackerNetworkInterface";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.AllowMMDS = is.read_bool()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.InRateLimiter)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.OutRateLimiter)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.CNIConfig)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.StaticConfig)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.AllowMMDS != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.InRateLimiter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.OutRateLimiter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.CNIConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.StaticConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.AllowMMDS != false {
            os.write_bool(1, self.AllowMMDS)?;
        }
        if let Some(v) = self.InRateLimiter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.OutRateLimiter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.CNIConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.StaticConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerNetworkInterface {
        FirecrackerNetworkInterface::new()
    }

    fn clear(&mut self) {
        self.AllowMMDS = false;
        self.InRateLimiter.clear();
        self.OutRateLimiter.clear();
        self.CNIConfig.clear();
        self.StaticConfig.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerNetworkInterface {
        static instance: FirecrackerNetworkInterface = FirecrackerNetworkInterface {
            AllowMMDS: false,
            InRateLimiter: ::protobuf::MessageField::none(),
            OutRateLimiter: ::protobuf::MessageField::none(),
            CNIConfig: ::protobuf::MessageField::none(),
            StaticConfig: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerNetworkInterface {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerNetworkInterface").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerNetworkInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerNetworkInterface {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.CNIConfiguration)
pub struct CNIConfiguration {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.NetworkName)
    pub NetworkName: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.InterfaceName)
    pub InterfaceName: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.BinPath)
    pub BinPath: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.ConfDir)
    pub ConfDir: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.CacheDir)
    pub CacheDir: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.Args)
    pub Args: ::std::vec::Vec<cniconfiguration::CNIArg>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.CNIConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNIConfiguration {
    fn default() -> &'a CNIConfiguration {
        <CNIConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl CNIConfiguration {
    pub fn new() -> CNIConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NetworkName",
            |m: &CNIConfiguration| { &m.NetworkName },
            |m: &mut CNIConfiguration| { &mut m.NetworkName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "InterfaceName",
            |m: &CNIConfiguration| { &m.InterfaceName },
            |m: &mut CNIConfiguration| { &mut m.InterfaceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "BinPath",
            |m: &CNIConfiguration| { &m.BinPath },
            |m: &mut CNIConfiguration| { &mut m.BinPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ConfDir",
            |m: &CNIConfiguration| { &m.ConfDir },
            |m: &mut CNIConfiguration| { &mut m.ConfDir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CacheDir",
            |m: &CNIConfiguration| { &m.CacheDir },
            |m: &mut CNIConfiguration| { &mut m.CacheDir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Args",
            |m: &CNIConfiguration| { &m.Args },
            |m: &mut CNIConfiguration| { &mut m.Args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNIConfiguration>(
            "CNIConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNIConfiguration {
    const NAME: &'static str = "CNIConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.NetworkName = is.read_string()?;
                },
                18 => {
                    self.InterfaceName = is.read_string()?;
                },
                26 => {
                    self.BinPath.push(is.read_string()?);
                },
                34 => {
                    self.ConfDir = is.read_string()?;
                },
                42 => {
                    self.CacheDir = is.read_string()?;
                },
                50 => {
                    self.Args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.NetworkName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.NetworkName);
        }
        if !self.InterfaceName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.InterfaceName);
        }
        for value in &self.BinPath {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.ConfDir.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ConfDir);
        }
        if !self.CacheDir.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.CacheDir);
        }
        for value in &self.Args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.NetworkName.is_empty() {
            os.write_string(1, &self.NetworkName)?;
        }
        if !self.InterfaceName.is_empty() {
            os.write_string(2, &self.InterfaceName)?;
        }
        for v in &self.BinPath {
            os.write_string(3, &v)?;
        };
        if !self.ConfDir.is_empty() {
            os.write_string(4, &self.ConfDir)?;
        }
        if !self.CacheDir.is_empty() {
            os.write_string(5, &self.CacheDir)?;
        }
        for v in &self.Args {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNIConfiguration {
        CNIConfiguration::new()
    }

    fn clear(&mut self) {
        self.NetworkName.clear();
        self.InterfaceName.clear();
        self.BinPath.clear();
        self.ConfDir.clear();
        self.CacheDir.clear();
        self.Args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNIConfiguration {
        static instance: CNIConfiguration = CNIConfiguration {
            NetworkName: ::std::string::String::new(),
            InterfaceName: ::std::string::String::new(),
            BinPath: ::std::vec::Vec::new(),
            ConfDir: ::std::string::String::new(),
            CacheDir: ::std::string::String::new(),
            Args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNIConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNIConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNIConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNIConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CNIConfiguration`
pub mod cniconfiguration {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:fc_ctrd.CNIConfiguration.CNIArg)
    pub struct CNIArg {
        // message fields
        // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.CNIArg.Key)
        pub Key: ::std::string::String,
        // @@protoc_insertion_point(field:fc_ctrd.CNIConfiguration.CNIArg.Value)
        pub Value: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:fc_ctrd.CNIConfiguration.CNIArg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CNIArg {
        fn default() -> &'a CNIArg {
            <CNIArg as ::protobuf::Message>::default_instance()
        }
    }

    impl CNIArg {
        pub fn new() -> CNIArg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Key",
                |m: &CNIArg| { &m.Key },
                |m: &mut CNIArg| { &mut m.Key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Value",
                |m: &CNIArg| { &m.Value },
                |m: &mut CNIArg| { &mut m.Value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNIArg>(
                "CNIConfiguration.CNIArg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CNIArg {
        const NAME: &'static str = "CNIArg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.Key = is.read_string()?;
                    },
                    18 => {
                        self.Value = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.Key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.Key);
            }
            if !self.Value.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.Value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.Key.is_empty() {
                os.write_string(1, &self.Key)?;
            }
            if !self.Value.is_empty() {
                os.write_string(2, &self.Value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CNIArg {
            CNIArg::new()
        }

        fn clear(&mut self) {
            self.Key.clear();
            self.Value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CNIArg {
            static instance: CNIArg = CNIArg {
                Key: ::std::string::String::new(),
                Value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CNIArg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CNIConfiguration.CNIArg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CNIArg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CNIArg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.StaticNetworkConfiguration)
pub struct StaticNetworkConfiguration {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.StaticNetworkConfiguration.MacAddress)
    pub MacAddress: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.StaticNetworkConfiguration.HostDevName)
    pub HostDevName: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.StaticNetworkConfiguration.IPConfig)
    pub IPConfig: ::protobuf::MessageField<IPConfiguration>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.StaticNetworkConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StaticNetworkConfiguration {
    fn default() -> &'a StaticNetworkConfiguration {
        <StaticNetworkConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl StaticNetworkConfiguration {
    pub fn new() -> StaticNetworkConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MacAddress",
            |m: &StaticNetworkConfiguration| { &m.MacAddress },
            |m: &mut StaticNetworkConfiguration| { &mut m.MacAddress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HostDevName",
            |m: &StaticNetworkConfiguration| { &m.HostDevName },
            |m: &mut StaticNetworkConfiguration| { &mut m.HostDevName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IPConfiguration>(
            "IPConfig",
            |m: &StaticNetworkConfiguration| { &m.IPConfig },
            |m: &mut StaticNetworkConfiguration| { &mut m.IPConfig },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StaticNetworkConfiguration>(
            "StaticNetworkConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StaticNetworkConfiguration {
    const NAME: &'static str = "StaticNetworkConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.MacAddress = is.read_string()?;
                },
                18 => {
                    self.HostDevName = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.IPConfig)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.MacAddress.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.MacAddress);
        }
        if !self.HostDevName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.HostDevName);
        }
        if let Some(v) = self.IPConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.MacAddress.is_empty() {
            os.write_string(1, &self.MacAddress)?;
        }
        if !self.HostDevName.is_empty() {
            os.write_string(2, &self.HostDevName)?;
        }
        if let Some(v) = self.IPConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StaticNetworkConfiguration {
        StaticNetworkConfiguration::new()
    }

    fn clear(&mut self) {
        self.MacAddress.clear();
        self.HostDevName.clear();
        self.IPConfig.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StaticNetworkConfiguration {
        static instance: StaticNetworkConfiguration = StaticNetworkConfiguration {
            MacAddress: ::std::string::String::new(),
            HostDevName: ::std::string::String::new(),
            IPConfig: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StaticNetworkConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StaticNetworkConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StaticNetworkConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StaticNetworkConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.IPConfiguration)
pub struct IPConfiguration {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.IPConfiguration.PrimaryAddr)
    pub PrimaryAddr: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.IPConfiguration.GatewayAddr)
    pub GatewayAddr: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.IPConfiguration.Nameservers)
    pub Nameservers: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.IPConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IPConfiguration {
    fn default() -> &'a IPConfiguration {
        <IPConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl IPConfiguration {
    pub fn new() -> IPConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PrimaryAddr",
            |m: &IPConfiguration| { &m.PrimaryAddr },
            |m: &mut IPConfiguration| { &mut m.PrimaryAddr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GatewayAddr",
            |m: &IPConfiguration| { &m.GatewayAddr },
            |m: &mut IPConfiguration| { &mut m.GatewayAddr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Nameservers",
            |m: &IPConfiguration| { &m.Nameservers },
            |m: &mut IPConfiguration| { &mut m.Nameservers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IPConfiguration>(
            "IPConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IPConfiguration {
    const NAME: &'static str = "IPConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.PrimaryAddr = is.read_string()?;
                },
                26 => {
                    self.GatewayAddr = is.read_string()?;
                },
                34 => {
                    self.Nameservers.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.PrimaryAddr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PrimaryAddr);
        }
        if !self.GatewayAddr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.GatewayAddr);
        }
        for value in &self.Nameservers {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.PrimaryAddr.is_empty() {
            os.write_string(1, &self.PrimaryAddr)?;
        }
        if !self.GatewayAddr.is_empty() {
            os.write_string(3, &self.GatewayAddr)?;
        }
        for v in &self.Nameservers {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IPConfiguration {
        IPConfiguration::new()
    }

    fn clear(&mut self) {
        self.PrimaryAddr.clear();
        self.GatewayAddr.clear();
        self.Nameservers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IPConfiguration {
        static instance: IPConfiguration = IPConfiguration {
            PrimaryAddr: ::std::string::String::new(),
            GatewayAddr: ::std::string::String::new(),
            Nameservers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IPConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IPConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IPConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerMachineConfiguration)
pub struct FirecrackerMachineConfiguration {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerMachineConfiguration.CPUTemplate)
    pub CPUTemplate: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerMachineConfiguration.HtEnabled)
    pub HtEnabled: bool,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerMachineConfiguration.MemSizeMib)
    pub MemSizeMib: u32,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerMachineConfiguration.VcpuCount)
    pub VcpuCount: u32,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerMachineConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerMachineConfiguration {
    fn default() -> &'a FirecrackerMachineConfiguration {
        <FirecrackerMachineConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerMachineConfiguration {
    pub fn new() -> FirecrackerMachineConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CPUTemplate",
            |m: &FirecrackerMachineConfiguration| { &m.CPUTemplate },
            |m: &mut FirecrackerMachineConfiguration| { &mut m.CPUTemplate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HtEnabled",
            |m: &FirecrackerMachineConfiguration| { &m.HtEnabled },
            |m: &mut FirecrackerMachineConfiguration| { &mut m.HtEnabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MemSizeMib",
            |m: &FirecrackerMachineConfiguration| { &m.MemSizeMib },
            |m: &mut FirecrackerMachineConfiguration| { &mut m.MemSizeMib },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VcpuCount",
            |m: &FirecrackerMachineConfiguration| { &m.VcpuCount },
            |m: &mut FirecrackerMachineConfiguration| { &mut m.VcpuCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerMachineConfiguration>(
            "FirecrackerMachineConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerMachineConfiguration {
    const NAME: &'static str = "FirecrackerMachineConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.CPUTemplate = is.read_string()?;
                },
                16 => {
                    self.HtEnabled = is.read_bool()?;
                },
                24 => {
                    self.MemSizeMib = is.read_uint32()?;
                },
                32 => {
                    self.VcpuCount = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.CPUTemplate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.CPUTemplate);
        }
        if self.HtEnabled != false {
            my_size += 1 + 1;
        }
        if self.MemSizeMib != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.MemSizeMib);
        }
        if self.VcpuCount != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.VcpuCount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.CPUTemplate.is_empty() {
            os.write_string(1, &self.CPUTemplate)?;
        }
        if self.HtEnabled != false {
            os.write_bool(2, self.HtEnabled)?;
        }
        if self.MemSizeMib != 0 {
            os.write_uint32(3, self.MemSizeMib)?;
        }
        if self.VcpuCount != 0 {
            os.write_uint32(4, self.VcpuCount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerMachineConfiguration {
        FirecrackerMachineConfiguration::new()
    }

    fn clear(&mut self) {
        self.CPUTemplate.clear();
        self.HtEnabled = false;
        self.MemSizeMib = 0;
        self.VcpuCount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerMachineConfiguration {
        static instance: FirecrackerMachineConfiguration = FirecrackerMachineConfiguration {
            CPUTemplate: ::std::string::String::new(),
            HtEnabled: false,
            MemSizeMib: 0,
            VcpuCount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerMachineConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerMachineConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerMachineConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerMachineConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerRootDrive)
pub struct FirecrackerRootDrive {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRootDrive.HostPath)
    pub HostPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRootDrive.Partuuid)
    pub Partuuid: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRootDrive.IsWritable)
    pub IsWritable: bool,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRootDrive.RateLimiter)
    pub RateLimiter: ::protobuf::MessageField<FirecrackerRateLimiter>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRootDrive.CacheType)
    pub CacheType: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerRootDrive.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerRootDrive {
    fn default() -> &'a FirecrackerRootDrive {
        <FirecrackerRootDrive as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerRootDrive {
    pub fn new() -> FirecrackerRootDrive {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HostPath",
            |m: &FirecrackerRootDrive| { &m.HostPath },
            |m: &mut FirecrackerRootDrive| { &mut m.HostPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Partuuid",
            |m: &FirecrackerRootDrive| { &m.Partuuid },
            |m: &mut FirecrackerRootDrive| { &mut m.Partuuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IsWritable",
            |m: &FirecrackerRootDrive| { &m.IsWritable },
            |m: &mut FirecrackerRootDrive| { &mut m.IsWritable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FirecrackerRateLimiter>(
            "RateLimiter",
            |m: &FirecrackerRootDrive| { &m.RateLimiter },
            |m: &mut FirecrackerRootDrive| { &mut m.RateLimiter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CacheType",
            |m: &FirecrackerRootDrive| { &m.CacheType },
            |m: &mut FirecrackerRootDrive| { &mut m.CacheType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerRootDrive>(
            "FirecrackerRootDrive",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerRootDrive {
    const NAME: &'static str = "FirecrackerRootDrive";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.HostPath = is.read_string()?;
                },
                18 => {
                    self.Partuuid = is.read_string()?;
                },
                24 => {
                    self.IsWritable = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.RateLimiter)?;
                },
                42 => {
                    self.CacheType = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.HostPath.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.HostPath);
        }
        if !self.Partuuid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Partuuid);
        }
        if self.IsWritable != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.RateLimiter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.CacheType.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.CacheType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.HostPath.is_empty() {
            os.write_string(1, &self.HostPath)?;
        }
        if !self.Partuuid.is_empty() {
            os.write_string(2, &self.Partuuid)?;
        }
        if self.IsWritable != false {
            os.write_bool(3, self.IsWritable)?;
        }
        if let Some(v) = self.RateLimiter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.CacheType.is_empty() {
            os.write_string(5, &self.CacheType)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerRootDrive {
        FirecrackerRootDrive::new()
    }

    fn clear(&mut self) {
        self.HostPath.clear();
        self.Partuuid.clear();
        self.IsWritable = false;
        self.RateLimiter.clear();
        self.CacheType.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerRootDrive {
        static instance: FirecrackerRootDrive = FirecrackerRootDrive {
            HostPath: ::std::string::String::new(),
            Partuuid: ::std::string::String::new(),
            IsWritable: false,
            RateLimiter: ::protobuf::MessageField::none(),
            CacheType: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerRootDrive {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerRootDrive").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerRootDrive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerRootDrive {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerDriveMount)
pub struct FirecrackerDriveMount {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.HostPath)
    pub HostPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.VMPath)
    pub VMPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.FilesystemType)
    pub FilesystemType: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.Options)
    pub Options: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.RateLimiter)
    pub RateLimiter: ::protobuf::MessageField<FirecrackerRateLimiter>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.IsWritable)
    pub IsWritable: bool,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerDriveMount.CacheType)
    pub CacheType: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerDriveMount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerDriveMount {
    fn default() -> &'a FirecrackerDriveMount {
        <FirecrackerDriveMount as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerDriveMount {
    pub fn new() -> FirecrackerDriveMount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HostPath",
            |m: &FirecrackerDriveMount| { &m.HostPath },
            |m: &mut FirecrackerDriveMount| { &mut m.HostPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMPath",
            |m: &FirecrackerDriveMount| { &m.VMPath },
            |m: &mut FirecrackerDriveMount| { &mut m.VMPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FilesystemType",
            |m: &FirecrackerDriveMount| { &m.FilesystemType },
            |m: &mut FirecrackerDriveMount| { &mut m.FilesystemType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Options",
            |m: &FirecrackerDriveMount| { &m.Options },
            |m: &mut FirecrackerDriveMount| { &mut m.Options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FirecrackerRateLimiter>(
            "RateLimiter",
            |m: &FirecrackerDriveMount| { &m.RateLimiter },
            |m: &mut FirecrackerDriveMount| { &mut m.RateLimiter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "IsWritable",
            |m: &FirecrackerDriveMount| { &m.IsWritable },
            |m: &mut FirecrackerDriveMount| { &mut m.IsWritable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CacheType",
            |m: &FirecrackerDriveMount| { &m.CacheType },
            |m: &mut FirecrackerDriveMount| { &mut m.CacheType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerDriveMount>(
            "FirecrackerDriveMount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerDriveMount {
    const NAME: &'static str = "FirecrackerDriveMount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.HostPath = is.read_string()?;
                },
                18 => {
                    self.VMPath = is.read_string()?;
                },
                26 => {
                    self.FilesystemType = is.read_string()?;
                },
                34 => {
                    self.Options.push(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.RateLimiter)?;
                },
                48 => {
                    self.IsWritable = is.read_bool()?;
                },
                58 => {
                    self.CacheType = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.HostPath.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.HostPath);
        }
        if !self.VMPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.VMPath);
        }
        if !self.FilesystemType.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.FilesystemType);
        }
        for value in &self.Options {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.RateLimiter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.IsWritable != false {
            my_size += 1 + 1;
        }
        if !self.CacheType.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.CacheType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.HostPath.is_empty() {
            os.write_string(1, &self.HostPath)?;
        }
        if !self.VMPath.is_empty() {
            os.write_string(2, &self.VMPath)?;
        }
        if !self.FilesystemType.is_empty() {
            os.write_string(3, &self.FilesystemType)?;
        }
        for v in &self.Options {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.RateLimiter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.IsWritable != false {
            os.write_bool(6, self.IsWritable)?;
        }
        if !self.CacheType.is_empty() {
            os.write_string(7, &self.CacheType)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerDriveMount {
        FirecrackerDriveMount::new()
    }

    fn clear(&mut self) {
        self.HostPath.clear();
        self.VMPath.clear();
        self.FilesystemType.clear();
        self.Options.clear();
        self.RateLimiter.clear();
        self.IsWritable = false;
        self.CacheType.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerDriveMount {
        static instance: FirecrackerDriveMount = FirecrackerDriveMount {
            HostPath: ::std::string::String::new(),
            VMPath: ::std::string::String::new(),
            FilesystemType: ::std::string::String::new(),
            Options: ::std::vec::Vec::new(),
            RateLimiter: ::protobuf::MessageField::none(),
            IsWritable: false,
            CacheType: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerDriveMount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerDriveMount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerDriveMount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerDriveMount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerRateLimiter)
pub struct FirecrackerRateLimiter {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRateLimiter.Bandwidth)
    pub Bandwidth: ::protobuf::MessageField<FirecrackerTokenBucket>,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerRateLimiter.Ops)
    pub Ops: ::protobuf::MessageField<FirecrackerTokenBucket>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerRateLimiter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerRateLimiter {
    fn default() -> &'a FirecrackerRateLimiter {
        <FirecrackerRateLimiter as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerRateLimiter {
    pub fn new() -> FirecrackerRateLimiter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FirecrackerTokenBucket>(
            "Bandwidth",
            |m: &FirecrackerRateLimiter| { &m.Bandwidth },
            |m: &mut FirecrackerRateLimiter| { &mut m.Bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FirecrackerTokenBucket>(
            "Ops",
            |m: &FirecrackerRateLimiter| { &m.Ops },
            |m: &mut FirecrackerRateLimiter| { &mut m.Ops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerRateLimiter>(
            "FirecrackerRateLimiter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerRateLimiter {
    const NAME: &'static str = "FirecrackerRateLimiter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Bandwidth)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Ops)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Bandwidth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Ops.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Bandwidth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.Ops.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerRateLimiter {
        FirecrackerRateLimiter::new()
    }

    fn clear(&mut self) {
        self.Bandwidth.clear();
        self.Ops.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerRateLimiter {
        static instance: FirecrackerRateLimiter = FirecrackerRateLimiter {
            Bandwidth: ::protobuf::MessageField::none(),
            Ops: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerRateLimiter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerRateLimiter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerRateLimiter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerRateLimiter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerTokenBucket)
pub struct FirecrackerTokenBucket {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerTokenBucket.OneTimeBurst)
    pub OneTimeBurst: i64,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerTokenBucket.RefillTime)
    pub RefillTime: i64,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerTokenBucket.Capacity)
    pub Capacity: i64,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerTokenBucket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerTokenBucket {
    fn default() -> &'a FirecrackerTokenBucket {
        <FirecrackerTokenBucket as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerTokenBucket {
    pub fn new() -> FirecrackerTokenBucket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OneTimeBurst",
            |m: &FirecrackerTokenBucket| { &m.OneTimeBurst },
            |m: &mut FirecrackerTokenBucket| { &mut m.OneTimeBurst },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "RefillTime",
            |m: &FirecrackerTokenBucket| { &m.RefillTime },
            |m: &mut FirecrackerTokenBucket| { &mut m.RefillTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Capacity",
            |m: &FirecrackerTokenBucket| { &m.Capacity },
            |m: &mut FirecrackerTokenBucket| { &mut m.Capacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerTokenBucket>(
            "FirecrackerTokenBucket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerTokenBucket {
    const NAME: &'static str = "FirecrackerTokenBucket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.OneTimeBurst = is.read_int64()?;
                },
                16 => {
                    self.RefillTime = is.read_int64()?;
                },
                24 => {
                    self.Capacity = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.OneTimeBurst != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.OneTimeBurst);
        }
        if self.RefillTime != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.RefillTime);
        }
        if self.Capacity != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.Capacity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.OneTimeBurst != 0 {
            os.write_int64(1, self.OneTimeBurst)?;
        }
        if self.RefillTime != 0 {
            os.write_int64(2, self.RefillTime)?;
        }
        if self.Capacity != 0 {
            os.write_int64(3, self.Capacity)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerTokenBucket {
        FirecrackerTokenBucket::new()
    }

    fn clear(&mut self) {
        self.OneTimeBurst = 0;
        self.RefillTime = 0;
        self.Capacity = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerTokenBucket {
        static instance: FirecrackerTokenBucket = FirecrackerTokenBucket {
            OneTimeBurst: 0,
            RefillTime: 0,
            Capacity: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerTokenBucket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerTokenBucket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerTokenBucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerTokenBucket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.FirecrackerBalloonDevice)
pub struct FirecrackerBalloonDevice {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerBalloonDevice.AmountMib)
    pub AmountMib: i64,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerBalloonDevice.DeflateOnOom)
    pub DeflateOnOom: bool,
    // @@protoc_insertion_point(field:fc_ctrd.FirecrackerBalloonDevice.StatsPollingIntervals)
    pub StatsPollingIntervals: i64,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.FirecrackerBalloonDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirecrackerBalloonDevice {
    fn default() -> &'a FirecrackerBalloonDevice {
        <FirecrackerBalloonDevice as ::protobuf::Message>::default_instance()
    }
}

impl FirecrackerBalloonDevice {
    pub fn new() -> FirecrackerBalloonDevice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AmountMib",
            |m: &FirecrackerBalloonDevice| { &m.AmountMib },
            |m: &mut FirecrackerBalloonDevice| { &mut m.AmountMib },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DeflateOnOom",
            |m: &FirecrackerBalloonDevice| { &m.DeflateOnOom },
            |m: &mut FirecrackerBalloonDevice| { &mut m.DeflateOnOom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StatsPollingIntervals",
            |m: &FirecrackerBalloonDevice| { &m.StatsPollingIntervals },
            |m: &mut FirecrackerBalloonDevice| { &mut m.StatsPollingIntervals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirecrackerBalloonDevice>(
            "FirecrackerBalloonDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirecrackerBalloonDevice {
    const NAME: &'static str = "FirecrackerBalloonDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.AmountMib = is.read_int64()?;
                },
                16 => {
                    self.DeflateOnOom = is.read_bool()?;
                },
                24 => {
                    self.StatsPollingIntervals = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.AmountMib != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.AmountMib);
        }
        if self.DeflateOnOom != false {
            my_size += 1 + 1;
        }
        if self.StatsPollingIntervals != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.StatsPollingIntervals);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.AmountMib != 0 {
            os.write_int64(1, self.AmountMib)?;
        }
        if self.DeflateOnOom != false {
            os.write_bool(2, self.DeflateOnOom)?;
        }
        if self.StatsPollingIntervals != 0 {
            os.write_int64(3, self.StatsPollingIntervals)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirecrackerBalloonDevice {
        FirecrackerBalloonDevice::new()
    }

    fn clear(&mut self) {
        self.AmountMib = 0;
        self.DeflateOnOom = false;
        self.StatsPollingIntervals = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirecrackerBalloonDevice {
        static instance: FirecrackerBalloonDevice = FirecrackerBalloonDevice {
            AmountMib: 0,
            DeflateOnOom: false,
            StatsPollingIntervals: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirecrackerBalloonDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirecrackerBalloonDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirecrackerBalloonDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirecrackerBalloonDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0btypes.proto\x12\x07fc_ctrd\x1a\x19google/protobuf/any.proto\"\xbd\
    \x01\n\tExtraData\x12\x1a\n\x08JsonSpec\x18\x01\x20\x01(\x0cR\x08JsonSpe\
    c\x126\n\x0bRuncOptions\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\
    \x0bRuncOptions\x12\x1c\n\tStdinPort\x18\x03\x20\x01(\rR\tStdinPort\x12\
    \x1e\n\nStdoutPort\x18\x04\x20\x01(\rR\nStdoutPort\x12\x1e\n\nStderrPort\
    \x18\x05\x20\x01(\rR\nStderrPort\"\xcd\x02\n\x1bFirecrackerNetworkInterf\
    ace\x12\x1c\n\tAllowMMDS\x18\x01\x20\x01(\x08R\tAllowMMDS\x12E\n\rInRate\
    Limiter\x18\x02\x20\x01(\x0b2\x1f.fc_ctrd.FirecrackerRateLimiterR\rInRat\
    eLimiter\x12G\n\x0eOutRateLimiter\x18\x03\x20\x01(\x0b2\x1f.fc_ctrd.Fire\
    crackerRateLimiterR\x0eOutRateLimiter\x127\n\tCNIConfig\x18\x04\x20\x01(\
    \x0b2\x19.fc_ctrd.CNIConfigurationR\tCNIConfig\x12G\n\x0cStaticConfig\
    \x18\x05\x20\x01(\x0b2#.fc_ctrd.StaticNetworkConfigurationR\x0cStaticCon\
    fig\"\x92\x02\n\x10CNIConfiguration\x12\x20\n\x0bNetworkName\x18\x01\x20\
    \x01(\tR\x0bNetworkName\x12$\n\rInterfaceName\x18\x02\x20\x01(\tR\rInter\
    faceName\x12\x18\n\x07BinPath\x18\x03\x20\x03(\tR\x07BinPath\x12\x18\n\
    \x07ConfDir\x18\x04\x20\x01(\tR\x07ConfDir\x12\x1a\n\x08CacheDir\x18\x05\
    \x20\x01(\tR\x08CacheDir\x124\n\x04Args\x18\x06\x20\x03(\x0b2\x20.fc_ctr\
    d.CNIConfiguration.CNIArgR\x04Args\x1a0\n\x06CNIArg\x12\x10\n\x03Key\x18\
    \x01\x20\x01(\tR\x03Key\x12\x14\n\x05Value\x18\x02\x20\x01(\tR\x05Value\
    \"\x94\x01\n\x1aStaticNetworkConfiguration\x12\x1e\n\nMacAddress\x18\x01\
    \x20\x01(\tR\nMacAddress\x12\x20\n\x0bHostDevName\x18\x02\x20\x01(\tR\
    \x0bHostDevName\x124\n\x08IPConfig\x18\x03\x20\x01(\x0b2\x18.fc_ctrd.IPC\
    onfigurationR\x08IPConfig\"w\n\x0fIPConfiguration\x12\x20\n\x0bPrimaryAd\
    dr\x18\x01\x20\x01(\tR\x0bPrimaryAddr\x12\x20\n\x0bGatewayAddr\x18\x03\
    \x20\x01(\tR\x0bGatewayAddr\x12\x20\n\x0bNameservers\x18\x04\x20\x03(\tR\
    \x0bNameservers\"\x9f\x01\n\x1fFirecrackerMachineConfiguration\x12\x20\n\
    \x0bCPUTemplate\x18\x01\x20\x01(\tR\x0bCPUTemplate\x12\x1c\n\tHtEnabled\
    \x18\x02\x20\x01(\x08R\tHtEnabled\x12\x1e\n\nMemSizeMib\x18\x03\x20\x01(\
    \rR\nMemSizeMib\x12\x1c\n\tVcpuCount\x18\x04\x20\x01(\rR\tVcpuCount\"\
    \xcf\x01\n\x14FirecrackerRootDrive\x12\x1a\n\x08HostPath\x18\x01\x20\x01\
    (\tR\x08HostPath\x12\x1a\n\x08Partuuid\x18\x02\x20\x01(\tR\x08Partuuid\
    \x12\x1e\n\nIsWritable\x18\x03\x20\x01(\x08R\nIsWritable\x12A\n\x0bRateL\
    imiter\x18\x04\x20\x01(\x0b2\x1f.fc_ctrd.FirecrackerRateLimiterR\x0bRate\
    Limiter\x12\x1c\n\tCacheType\x18\x05\x20\x01(\tR\tCacheType\"\x8e\x02\n\
    \x15FirecrackerDriveMount\x12\x1a\n\x08HostPath\x18\x01\x20\x01(\tR\x08H\
    ostPath\x12\x16\n\x06VMPath\x18\x02\x20\x01(\tR\x06VMPath\x12&\n\x0eFile\
    systemType\x18\x03\x20\x01(\tR\x0eFilesystemType\x12\x18\n\x07Options\
    \x18\x04\x20\x03(\tR\x07Options\x12A\n\x0bRateLimiter\x18\x05\x20\x01(\
    \x0b2\x1f.fc_ctrd.FirecrackerRateLimiterR\x0bRateLimiter\x12\x1e\n\nIsWr\
    itable\x18\x06\x20\x01(\x08R\nIsWritable\x12\x1c\n\tCacheType\x18\x07\
    \x20\x01(\tR\tCacheType\"\x8a\x01\n\x16FirecrackerRateLimiter\x12=\n\tBa\
    ndwidth\x18\x01\x20\x01(\x0b2\x1f.fc_ctrd.FirecrackerTokenBucketR\tBandw\
    idth\x121\n\x03Ops\x18\x02\x20\x01(\x0b2\x1f.fc_ctrd.FirecrackerTokenBuc\
    ketR\x03Ops\"x\n\x16FirecrackerTokenBucket\x12\"\n\x0cOneTimeBurst\x18\
    \x01\x20\x01(\x03R\x0cOneTimeBurst\x12\x1e\n\nRefillTime\x18\x02\x20\x01\
    (\x03R\nRefillTime\x12\x1a\n\x08Capacity\x18\x03\x20\x01(\x03R\x08Capaci\
    ty\"\x92\x01\n\x18FirecrackerBalloonDevice\x12\x1c\n\tAmountMib\x18\x01\
    \x20\x01(\x03R\tAmountMib\x12\"\n\x0cDeflateOnOom\x18\x02\x20\x01(\x08R\
    \x0cDeflateOnOom\x124\n\x15StatsPollingIntervals\x18\x03\x20\x01(\x03R\
    \x15StatsPollingIntervalsB\x07Z\x05protob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(ExtraData::generated_message_descriptor_data());
            messages.push(FirecrackerNetworkInterface::generated_message_descriptor_data());
            messages.push(CNIConfiguration::generated_message_descriptor_data());
            messages.push(StaticNetworkConfiguration::generated_message_descriptor_data());
            messages.push(IPConfiguration::generated_message_descriptor_data());
            messages.push(FirecrackerMachineConfiguration::generated_message_descriptor_data());
            messages.push(FirecrackerRootDrive::generated_message_descriptor_data());
            messages.push(FirecrackerDriveMount::generated_message_descriptor_data());
            messages.push(FirecrackerRateLimiter::generated_message_descriptor_data());
            messages.push(FirecrackerTokenBucket::generated_message_descriptor_data());
            messages.push(FirecrackerBalloonDevice::generated_message_descriptor_data());
            messages.push(cniconfiguration::CNIArg::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
