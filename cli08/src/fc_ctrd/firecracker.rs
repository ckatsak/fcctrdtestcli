// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `firecracker.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.CreateVMRequest)
pub struct CreateVMRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.MachineCfg)
    pub MachineCfg: ::protobuf::MessageField<super::types::FirecrackerMachineConfiguration>,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.KernelImagePath)
    pub KernelImagePath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.KernelArgs)
    pub KernelArgs: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.RootDrive)
    pub RootDrive: ::protobuf::MessageField<super::types::FirecrackerRootDrive>,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.DriveMounts)
    pub DriveMounts: ::std::vec::Vec<super::types::FirecrackerDriveMount>,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.NetworkInterfaces)
    pub NetworkInterfaces: ::std::vec::Vec<super::types::FirecrackerNetworkInterface>,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.ContainerCount)
    pub ContainerCount: i32,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.ExitAfterAllTasksDeleted)
    pub ExitAfterAllTasksDeleted: bool,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.JailerConfig)
    pub JailerConfig: ::protobuf::MessageField<JailerConfig>,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.TimeoutSeconds)
    pub TimeoutSeconds: u32,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.LogFifoPath)
    pub LogFifoPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.MetricsFifoPath)
    pub MetricsFifoPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMRequest.BalloonDevice)
    pub BalloonDevice: ::protobuf::MessageField<super::types::FirecrackerBalloonDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.CreateVMRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateVMRequest {
    fn default() -> &'a CreateVMRequest {
        <CreateVMRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateVMRequest {
    pub fn new() -> CreateVMRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &CreateVMRequest| { &m.VMID },
            |m: &mut CreateVMRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::FirecrackerMachineConfiguration>(
            "MachineCfg",
            |m: &CreateVMRequest| { &m.MachineCfg },
            |m: &mut CreateVMRequest| { &mut m.MachineCfg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KernelImagePath",
            |m: &CreateVMRequest| { &m.KernelImagePath },
            |m: &mut CreateVMRequest| { &mut m.KernelImagePath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "KernelArgs",
            |m: &CreateVMRequest| { &m.KernelArgs },
            |m: &mut CreateVMRequest| { &mut m.KernelArgs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::FirecrackerRootDrive>(
            "RootDrive",
            |m: &CreateVMRequest| { &m.RootDrive },
            |m: &mut CreateVMRequest| { &mut m.RootDrive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DriveMounts",
            |m: &CreateVMRequest| { &m.DriveMounts },
            |m: &mut CreateVMRequest| { &mut m.DriveMounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "NetworkInterfaces",
            |m: &CreateVMRequest| { &m.NetworkInterfaces },
            |m: &mut CreateVMRequest| { &mut m.NetworkInterfaces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ContainerCount",
            |m: &CreateVMRequest| { &m.ContainerCount },
            |m: &mut CreateVMRequest| { &mut m.ContainerCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ExitAfterAllTasksDeleted",
            |m: &CreateVMRequest| { &m.ExitAfterAllTasksDeleted },
            |m: &mut CreateVMRequest| { &mut m.ExitAfterAllTasksDeleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JailerConfig>(
            "JailerConfig",
            |m: &CreateVMRequest| { &m.JailerConfig },
            |m: &mut CreateVMRequest| { &mut m.JailerConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TimeoutSeconds",
            |m: &CreateVMRequest| { &m.TimeoutSeconds },
            |m: &mut CreateVMRequest| { &mut m.TimeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LogFifoPath",
            |m: &CreateVMRequest| { &m.LogFifoPath },
            |m: &mut CreateVMRequest| { &mut m.LogFifoPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetricsFifoPath",
            |m: &CreateVMRequest| { &m.MetricsFifoPath },
            |m: &mut CreateVMRequest| { &mut m.MetricsFifoPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::FirecrackerBalloonDevice>(
            "BalloonDevice",
            |m: &CreateVMRequest| { &m.BalloonDevice },
            |m: &mut CreateVMRequest| { &mut m.BalloonDevice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateVMRequest>(
            "CreateVMRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateVMRequest {
    const NAME: &'static str = "CreateVMRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MachineCfg)?;
                },
                26 => {
                    self.KernelImagePath = is.read_string()?;
                },
                34 => {
                    self.KernelArgs = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.RootDrive)?;
                },
                50 => {
                    self.DriveMounts.push(is.read_message()?);
                },
                58 => {
                    self.NetworkInterfaces.push(is.read_message()?);
                },
                64 => {
                    self.ContainerCount = is.read_int32()?;
                },
                72 => {
                    self.ExitAfterAllTasksDeleted = is.read_bool()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.JailerConfig)?;
                },
                88 => {
                    self.TimeoutSeconds = is.read_uint32()?;
                },
                98 => {
                    self.LogFifoPath = is.read_string()?;
                },
                106 => {
                    self.MetricsFifoPath = is.read_string()?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.BalloonDevice)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if let Some(v) = self.MachineCfg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.KernelImagePath.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.KernelImagePath);
        }
        if !self.KernelArgs.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.KernelArgs);
        }
        if let Some(v) = self.RootDrive.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.DriveMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.NetworkInterfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.ContainerCount != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.ContainerCount);
        }
        if self.ExitAfterAllTasksDeleted != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.JailerConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.TimeoutSeconds != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.TimeoutSeconds);
        }
        if !self.LogFifoPath.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.LogFifoPath);
        }
        if !self.MetricsFifoPath.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.MetricsFifoPath);
        }
        if let Some(v) = self.BalloonDevice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if let Some(v) = self.MachineCfg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.KernelImagePath.is_empty() {
            os.write_string(3, &self.KernelImagePath)?;
        }
        if !self.KernelArgs.is_empty() {
            os.write_string(4, &self.KernelArgs)?;
        }
        if let Some(v) = self.RootDrive.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.DriveMounts {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.NetworkInterfaces {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.ContainerCount != 0 {
            os.write_int32(8, self.ContainerCount)?;
        }
        if self.ExitAfterAllTasksDeleted != false {
            os.write_bool(9, self.ExitAfterAllTasksDeleted)?;
        }
        if let Some(v) = self.JailerConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.TimeoutSeconds != 0 {
            os.write_uint32(11, self.TimeoutSeconds)?;
        }
        if !self.LogFifoPath.is_empty() {
            os.write_string(12, &self.LogFifoPath)?;
        }
        if !self.MetricsFifoPath.is_empty() {
            os.write_string(13, &self.MetricsFifoPath)?;
        }
        if let Some(v) = self.BalloonDevice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateVMRequest {
        CreateVMRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.MachineCfg.clear();
        self.KernelImagePath.clear();
        self.KernelArgs.clear();
        self.RootDrive.clear();
        self.DriveMounts.clear();
        self.NetworkInterfaces.clear();
        self.ContainerCount = 0;
        self.ExitAfterAllTasksDeleted = false;
        self.JailerConfig.clear();
        self.TimeoutSeconds = 0;
        self.LogFifoPath.clear();
        self.MetricsFifoPath.clear();
        self.BalloonDevice.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateVMRequest {
        static instance: CreateVMRequest = CreateVMRequest {
            VMID: ::std::string::String::new(),
            MachineCfg: ::protobuf::MessageField::none(),
            KernelImagePath: ::std::string::String::new(),
            KernelArgs: ::std::string::String::new(),
            RootDrive: ::protobuf::MessageField::none(),
            DriveMounts: ::std::vec::Vec::new(),
            NetworkInterfaces: ::std::vec::Vec::new(),
            ContainerCount: 0,
            ExitAfterAllTasksDeleted: false,
            JailerConfig: ::protobuf::MessageField::none(),
            TimeoutSeconds: 0,
            LogFifoPath: ::std::string::String::new(),
            MetricsFifoPath: ::std::string::String::new(),
            BalloonDevice: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateVMRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateVMRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateVMRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVMRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.CreateVMResponse)
pub struct CreateVMResponse {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMResponse.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMResponse.SocketPath)
    pub SocketPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMResponse.LogFifoPath)
    pub LogFifoPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMResponse.MetricsFifoPath)
    pub MetricsFifoPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMResponse.CgroupPath)
    pub CgroupPath: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.CreateVMResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateVMResponse {
    fn default() -> &'a CreateVMResponse {
        <CreateVMResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateVMResponse {
    pub fn new() -> CreateVMResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &CreateVMResponse| { &m.VMID },
            |m: &mut CreateVMResponse| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SocketPath",
            |m: &CreateVMResponse| { &m.SocketPath },
            |m: &mut CreateVMResponse| { &mut m.SocketPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LogFifoPath",
            |m: &CreateVMResponse| { &m.LogFifoPath },
            |m: &mut CreateVMResponse| { &mut m.LogFifoPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetricsFifoPath",
            |m: &CreateVMResponse| { &m.MetricsFifoPath },
            |m: &mut CreateVMResponse| { &mut m.MetricsFifoPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CgroupPath",
            |m: &CreateVMResponse| { &m.CgroupPath },
            |m: &mut CreateVMResponse| { &mut m.CgroupPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateVMResponse>(
            "CreateVMResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateVMResponse {
    const NAME: &'static str = "CreateVMResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    self.SocketPath = is.read_string()?;
                },
                26 => {
                    self.LogFifoPath = is.read_string()?;
                },
                34 => {
                    self.MetricsFifoPath = is.read_string()?;
                },
                42 => {
                    self.CgroupPath = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if !self.SocketPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SocketPath);
        }
        if !self.LogFifoPath.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.LogFifoPath);
        }
        if !self.MetricsFifoPath.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.MetricsFifoPath);
        }
        if !self.CgroupPath.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.CgroupPath);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if !self.SocketPath.is_empty() {
            os.write_string(2, &self.SocketPath)?;
        }
        if !self.LogFifoPath.is_empty() {
            os.write_string(3, &self.LogFifoPath)?;
        }
        if !self.MetricsFifoPath.is_empty() {
            os.write_string(4, &self.MetricsFifoPath)?;
        }
        if !self.CgroupPath.is_empty() {
            os.write_string(5, &self.CgroupPath)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateVMResponse {
        CreateVMResponse::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.SocketPath.clear();
        self.LogFifoPath.clear();
        self.MetricsFifoPath.clear();
        self.CgroupPath.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateVMResponse {
        static instance: CreateVMResponse = CreateVMResponse {
            VMID: ::std::string::String::new(),
            SocketPath: ::std::string::String::new(),
            LogFifoPath: ::std::string::String::new(),
            MetricsFifoPath: ::std::string::String::new(),
            CgroupPath: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateVMResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateVMResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateVMResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVMResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.PauseVMRequest)
pub struct PauseVMRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.PauseVMRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.PauseVMRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PauseVMRequest {
    fn default() -> &'a PauseVMRequest {
        <PauseVMRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseVMRequest {
    pub fn new() -> PauseVMRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &PauseVMRequest| { &m.VMID },
            |m: &mut PauseVMRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PauseVMRequest>(
            "PauseVMRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PauseVMRequest {
    const NAME: &'static str = "PauseVMRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PauseVMRequest {
        PauseVMRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PauseVMRequest {
        static instance: PauseVMRequest = PauseVMRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PauseVMRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PauseVMRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PauseVMRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseVMRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.ResumeVMRequest)
pub struct ResumeVMRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.ResumeVMRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.ResumeVMRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResumeVMRequest {
    fn default() -> &'a ResumeVMRequest {
        <ResumeVMRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumeVMRequest {
    pub fn new() -> ResumeVMRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &ResumeVMRequest| { &m.VMID },
            |m: &mut ResumeVMRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResumeVMRequest>(
            "ResumeVMRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResumeVMRequest {
    const NAME: &'static str = "ResumeVMRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResumeVMRequest {
        ResumeVMRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResumeVMRequest {
        static instance: ResumeVMRequest = ResumeVMRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResumeVMRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResumeVMRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResumeVMRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeVMRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.CreateVMSnapshotRequest)
pub struct CreateVMSnapshotRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMSnapshotRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMSnapshotRequest.SnapshotPath)
    pub SnapshotPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.CreateVMSnapshotRequest.MemFilePath)
    pub MemFilePath: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.CreateVMSnapshotRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateVMSnapshotRequest {
    fn default() -> &'a CreateVMSnapshotRequest {
        <CreateVMSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateVMSnapshotRequest {
    pub fn new() -> CreateVMSnapshotRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &CreateVMSnapshotRequest| { &m.VMID },
            |m: &mut CreateVMSnapshotRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SnapshotPath",
            |m: &CreateVMSnapshotRequest| { &m.SnapshotPath },
            |m: &mut CreateVMSnapshotRequest| { &mut m.SnapshotPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MemFilePath",
            |m: &CreateVMSnapshotRequest| { &m.MemFilePath },
            |m: &mut CreateVMSnapshotRequest| { &mut m.MemFilePath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateVMSnapshotRequest>(
            "CreateVMSnapshotRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateVMSnapshotRequest {
    const NAME: &'static str = "CreateVMSnapshotRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    self.SnapshotPath = is.read_string()?;
                },
                26 => {
                    self.MemFilePath = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if !self.SnapshotPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SnapshotPath);
        }
        if !self.MemFilePath.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.MemFilePath);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if !self.SnapshotPath.is_empty() {
            os.write_string(2, &self.SnapshotPath)?;
        }
        if !self.MemFilePath.is_empty() {
            os.write_string(3, &self.MemFilePath)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateVMSnapshotRequest {
        CreateVMSnapshotRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.SnapshotPath.clear();
        self.MemFilePath.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateVMSnapshotRequest {
        static instance: CreateVMSnapshotRequest = CreateVMSnapshotRequest {
            VMID: ::std::string::String::new(),
            SnapshotPath: ::std::string::String::new(),
            MemFilePath: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateVMSnapshotRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateVMSnapshotRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateVMSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVMSnapshotRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.LoadVMSnapshotRequest)
pub struct LoadVMSnapshotRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.LoadVMSnapshotRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.LoadVMSnapshotRequest.SnapshotPath)
    pub SnapshotPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.LoadVMSnapshotRequest.MemFilePath)
    pub MemFilePath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.LoadVMSnapshotRequest.ResumeVM)
    pub ResumeVM: bool,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.LoadVMSnapshotRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadVMSnapshotRequest {
    fn default() -> &'a LoadVMSnapshotRequest {
        <LoadVMSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoadVMSnapshotRequest {
    pub fn new() -> LoadVMSnapshotRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &LoadVMSnapshotRequest| { &m.VMID },
            |m: &mut LoadVMSnapshotRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SnapshotPath",
            |m: &LoadVMSnapshotRequest| { &m.SnapshotPath },
            |m: &mut LoadVMSnapshotRequest| { &mut m.SnapshotPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MemFilePath",
            |m: &LoadVMSnapshotRequest| { &m.MemFilePath },
            |m: &mut LoadVMSnapshotRequest| { &mut m.MemFilePath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ResumeVM",
            |m: &LoadVMSnapshotRequest| { &m.ResumeVM },
            |m: &mut LoadVMSnapshotRequest| { &mut m.ResumeVM },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadVMSnapshotRequest>(
            "LoadVMSnapshotRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadVMSnapshotRequest {
    const NAME: &'static str = "LoadVMSnapshotRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    self.SnapshotPath = is.read_string()?;
                },
                26 => {
                    self.MemFilePath = is.read_string()?;
                },
                32 => {
                    self.ResumeVM = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if !self.SnapshotPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SnapshotPath);
        }
        if !self.MemFilePath.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.MemFilePath);
        }
        if self.ResumeVM != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if !self.SnapshotPath.is_empty() {
            os.write_string(2, &self.SnapshotPath)?;
        }
        if !self.MemFilePath.is_empty() {
            os.write_string(3, &self.MemFilePath)?;
        }
        if self.ResumeVM != false {
            os.write_bool(4, self.ResumeVM)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadVMSnapshotRequest {
        LoadVMSnapshotRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.SnapshotPath.clear();
        self.MemFilePath.clear();
        self.ResumeVM = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadVMSnapshotRequest {
        static instance: LoadVMSnapshotRequest = LoadVMSnapshotRequest {
            VMID: ::std::string::String::new(),
            SnapshotPath: ::std::string::String::new(),
            MemFilePath: ::std::string::String::new(),
            ResumeVM: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadVMSnapshotRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadVMSnapshotRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadVMSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadVMSnapshotRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.UnloadVMRequest)
pub struct UnloadVMRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.UnloadVMRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.UnloadVMRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnloadVMRequest {
    fn default() -> &'a UnloadVMRequest {
        <UnloadVMRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnloadVMRequest {
    pub fn new() -> UnloadVMRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &UnloadVMRequest| { &m.VMID },
            |m: &mut UnloadVMRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnloadVMRequest>(
            "UnloadVMRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnloadVMRequest {
    const NAME: &'static str = "UnloadVMRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnloadVMRequest {
        UnloadVMRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnloadVMRequest {
        static instance: UnloadVMRequest = UnloadVMRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnloadVMRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnloadVMRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnloadVMRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnloadVMRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.StopVMRequest)
pub struct StopVMRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.StopVMRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.StopVMRequest.TimeoutSeconds)
    pub TimeoutSeconds: u32,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.StopVMRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StopVMRequest {
    fn default() -> &'a StopVMRequest {
        <StopVMRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopVMRequest {
    pub fn new() -> StopVMRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &StopVMRequest| { &m.VMID },
            |m: &mut StopVMRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TimeoutSeconds",
            |m: &StopVMRequest| { &m.TimeoutSeconds },
            |m: &mut StopVMRequest| { &mut m.TimeoutSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopVMRequest>(
            "StopVMRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StopVMRequest {
    const NAME: &'static str = "StopVMRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                16 => {
                    self.TimeoutSeconds = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if self.TimeoutSeconds != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.TimeoutSeconds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if self.TimeoutSeconds != 0 {
            os.write_uint32(2, self.TimeoutSeconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StopVMRequest {
        StopVMRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.TimeoutSeconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StopVMRequest {
        static instance: StopVMRequest = StopVMRequest {
            VMID: ::std::string::String::new(),
            TimeoutSeconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StopVMRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StopVMRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StopVMRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopVMRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetVMInfoRequest)
pub struct GetVMInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetVMInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVMInfoRequest {
    fn default() -> &'a GetVMInfoRequest {
        <GetVMInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVMInfoRequest {
    pub fn new() -> GetVMInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &GetVMInfoRequest| { &m.VMID },
            |m: &mut GetVMInfoRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVMInfoRequest>(
            "GetVMInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVMInfoRequest {
    const NAME: &'static str = "GetVMInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVMInfoRequest {
        GetVMInfoRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVMInfoRequest {
        static instance: GetVMInfoRequest = GetVMInfoRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVMInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVMInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVMInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVMInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetVMInfoResponse)
pub struct GetVMInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoResponse.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoResponse.SocketPath)
    pub SocketPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoResponse.LogFifoPath)
    pub LogFifoPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoResponse.MetricsFifoPath)
    pub MetricsFifoPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoResponse.CgroupPath)
    pub CgroupPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.GetVMInfoResponse.VSockPath)
    pub VSockPath: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetVMInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVMInfoResponse {
    fn default() -> &'a GetVMInfoResponse {
        <GetVMInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetVMInfoResponse {
    pub fn new() -> GetVMInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &GetVMInfoResponse| { &m.VMID },
            |m: &mut GetVMInfoResponse| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SocketPath",
            |m: &GetVMInfoResponse| { &m.SocketPath },
            |m: &mut GetVMInfoResponse| { &mut m.SocketPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LogFifoPath",
            |m: &GetVMInfoResponse| { &m.LogFifoPath },
            |m: &mut GetVMInfoResponse| { &mut m.LogFifoPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetricsFifoPath",
            |m: &GetVMInfoResponse| { &m.MetricsFifoPath },
            |m: &mut GetVMInfoResponse| { &mut m.MetricsFifoPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CgroupPath",
            |m: &GetVMInfoResponse| { &m.CgroupPath },
            |m: &mut GetVMInfoResponse| { &mut m.CgroupPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VSockPath",
            |m: &GetVMInfoResponse| { &m.VSockPath },
            |m: &mut GetVMInfoResponse| { &mut m.VSockPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVMInfoResponse>(
            "GetVMInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVMInfoResponse {
    const NAME: &'static str = "GetVMInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    self.SocketPath = is.read_string()?;
                },
                26 => {
                    self.LogFifoPath = is.read_string()?;
                },
                34 => {
                    self.MetricsFifoPath = is.read_string()?;
                },
                42 => {
                    self.CgroupPath = is.read_string()?;
                },
                50 => {
                    self.VSockPath = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if !self.SocketPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SocketPath);
        }
        if !self.LogFifoPath.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.LogFifoPath);
        }
        if !self.MetricsFifoPath.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.MetricsFifoPath);
        }
        if !self.CgroupPath.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.CgroupPath);
        }
        if !self.VSockPath.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.VSockPath);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if !self.SocketPath.is_empty() {
            os.write_string(2, &self.SocketPath)?;
        }
        if !self.LogFifoPath.is_empty() {
            os.write_string(3, &self.LogFifoPath)?;
        }
        if !self.MetricsFifoPath.is_empty() {
            os.write_string(4, &self.MetricsFifoPath)?;
        }
        if !self.CgroupPath.is_empty() {
            os.write_string(5, &self.CgroupPath)?;
        }
        if !self.VSockPath.is_empty() {
            os.write_string(6, &self.VSockPath)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVMInfoResponse {
        GetVMInfoResponse::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.SocketPath.clear();
        self.LogFifoPath.clear();
        self.MetricsFifoPath.clear();
        self.CgroupPath.clear();
        self.VSockPath.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVMInfoResponse {
        static instance: GetVMInfoResponse = GetVMInfoResponse {
            VMID: ::std::string::String::new(),
            SocketPath: ::std::string::String::new(),
            LogFifoPath: ::std::string::String::new(),
            MetricsFifoPath: ::std::string::String::new(),
            CgroupPath: ::std::string::String::new(),
            VSockPath: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVMInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVMInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVMInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVMInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.SetVMMetadataRequest)
pub struct SetVMMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.SetVMMetadataRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.SetVMMetadataRequest.Metadata)
    pub Metadata: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.SetVMMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetVMMetadataRequest {
    fn default() -> &'a SetVMMetadataRequest {
        <SetVMMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetVMMetadataRequest {
    pub fn new() -> SetVMMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &SetVMMetadataRequest| { &m.VMID },
            |m: &mut SetVMMetadataRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Metadata",
            |m: &SetVMMetadataRequest| { &m.Metadata },
            |m: &mut SetVMMetadataRequest| { &mut m.Metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetVMMetadataRequest>(
            "SetVMMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetVMMetadataRequest {
    const NAME: &'static str = "SetVMMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    self.Metadata = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if !self.Metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if !self.Metadata.is_empty() {
            os.write_string(2, &self.Metadata)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetVMMetadataRequest {
        SetVMMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.Metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetVMMetadataRequest {
        static instance: SetVMMetadataRequest = SetVMMetadataRequest {
            VMID: ::std::string::String::new(),
            Metadata: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetVMMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetVMMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetVMMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVMMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.UpdateVMMetadataRequest)
pub struct UpdateVMMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.UpdateVMMetadataRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.UpdateVMMetadataRequest.Metadata)
    pub Metadata: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.UpdateVMMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateVMMetadataRequest {
    fn default() -> &'a UpdateVMMetadataRequest {
        <UpdateVMMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateVMMetadataRequest {
    pub fn new() -> UpdateVMMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &UpdateVMMetadataRequest| { &m.VMID },
            |m: &mut UpdateVMMetadataRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Metadata",
            |m: &UpdateVMMetadataRequest| { &m.Metadata },
            |m: &mut UpdateVMMetadataRequest| { &mut m.Metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateVMMetadataRequest>(
            "UpdateVMMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateVMMetadataRequest {
    const NAME: &'static str = "UpdateVMMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                18 => {
                    self.Metadata = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if !self.Metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if !self.Metadata.is_empty() {
            os.write_string(2, &self.Metadata)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateVMMetadataRequest {
        UpdateVMMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.Metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateVMMetadataRequest {
        static instance: UpdateVMMetadataRequest = UpdateVMMetadataRequest {
            VMID: ::std::string::String::new(),
            Metadata: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateVMMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateVMMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateVMMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateVMMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetVMMetadataRequest)
pub struct GetVMMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetVMMetadataRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetVMMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVMMetadataRequest {
    fn default() -> &'a GetVMMetadataRequest {
        <GetVMMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVMMetadataRequest {
    pub fn new() -> GetVMMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &GetVMMetadataRequest| { &m.VMID },
            |m: &mut GetVMMetadataRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVMMetadataRequest>(
            "GetVMMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVMMetadataRequest {
    const NAME: &'static str = "GetVMMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVMMetadataRequest {
        GetVMMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVMMetadataRequest {
        static instance: GetVMMetadataRequest = GetVMMetadataRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVMMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVMMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVMMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVMMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetVMMetadataResponse)
pub struct GetVMMetadataResponse {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetVMMetadataResponse.Metadata)
    pub Metadata: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetVMMetadataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVMMetadataResponse {
    fn default() -> &'a GetVMMetadataResponse {
        <GetVMMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetVMMetadataResponse {
    pub fn new() -> GetVMMetadataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Metadata",
            |m: &GetVMMetadataResponse| { &m.Metadata },
            |m: &mut GetVMMetadataResponse| { &mut m.Metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVMMetadataResponse>(
            "GetVMMetadataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVMMetadataResponse {
    const NAME: &'static str = "GetVMMetadataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Metadata = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Metadata.is_empty() {
            os.write_string(1, &self.Metadata)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVMMetadataResponse {
        GetVMMetadataResponse::new()
    }

    fn clear(&mut self) {
        self.Metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVMMetadataResponse {
        static instance: GetVMMetadataResponse = GetVMMetadataResponse {
            Metadata: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVMMetadataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVMMetadataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVMMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVMMetadataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.JailerConfig)
pub struct JailerConfig {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.NetNS)
    pub NetNS: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.CPUs)
    pub CPUs: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.Mems)
    pub Mems: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.UID)
    pub UID: u32,
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.GID)
    pub GID: u32,
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.CgroupPath)
    pub CgroupPath: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.JailerConfig.DriveExposePolicy)
    pub DriveExposePolicy: ::protobuf::EnumOrUnknown<DriveExposePolicy>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.JailerConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JailerConfig {
    fn default() -> &'a JailerConfig {
        <JailerConfig as ::protobuf::Message>::default_instance()
    }
}

impl JailerConfig {
    pub fn new() -> JailerConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NetNS",
            |m: &JailerConfig| { &m.NetNS },
            |m: &mut JailerConfig| { &mut m.NetNS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CPUs",
            |m: &JailerConfig| { &m.CPUs },
            |m: &mut JailerConfig| { &mut m.CPUs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Mems",
            |m: &JailerConfig| { &m.Mems },
            |m: &mut JailerConfig| { &mut m.Mems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UID",
            |m: &JailerConfig| { &m.UID },
            |m: &mut JailerConfig| { &mut m.UID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "GID",
            |m: &JailerConfig| { &m.GID },
            |m: &mut JailerConfig| { &mut m.GID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CgroupPath",
            |m: &JailerConfig| { &m.CgroupPath },
            |m: &mut JailerConfig| { &mut m.CgroupPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DriveExposePolicy",
            |m: &JailerConfig| { &m.DriveExposePolicy },
            |m: &mut JailerConfig| { &mut m.DriveExposePolicy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JailerConfig>(
            "JailerConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JailerConfig {
    const NAME: &'static str = "JailerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.NetNS = is.read_string()?;
                },
                18 => {
                    self.CPUs = is.read_string()?;
                },
                26 => {
                    self.Mems = is.read_string()?;
                },
                32 => {
                    self.UID = is.read_uint32()?;
                },
                40 => {
                    self.GID = is.read_uint32()?;
                },
                50 => {
                    self.CgroupPath = is.read_string()?;
                },
                56 => {
                    self.DriveExposePolicy = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.NetNS.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.NetNS);
        }
        if !self.CPUs.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.CPUs);
        }
        if !self.Mems.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Mems);
        }
        if self.UID != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.UID);
        }
        if self.GID != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.GID);
        }
        if !self.CgroupPath.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.CgroupPath);
        }
        if self.DriveExposePolicy != ::protobuf::EnumOrUnknown::new(DriveExposePolicy::COPY) {
            my_size += ::protobuf::rt::int32_size(7, self.DriveExposePolicy.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.NetNS.is_empty() {
            os.write_string(1, &self.NetNS)?;
        }
        if !self.CPUs.is_empty() {
            os.write_string(2, &self.CPUs)?;
        }
        if !self.Mems.is_empty() {
            os.write_string(3, &self.Mems)?;
        }
        if self.UID != 0 {
            os.write_uint32(4, self.UID)?;
        }
        if self.GID != 0 {
            os.write_uint32(5, self.GID)?;
        }
        if !self.CgroupPath.is_empty() {
            os.write_string(6, &self.CgroupPath)?;
        }
        if self.DriveExposePolicy != ::protobuf::EnumOrUnknown::new(DriveExposePolicy::COPY) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.DriveExposePolicy))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JailerConfig {
        JailerConfig::new()
    }

    fn clear(&mut self) {
        self.NetNS.clear();
        self.CPUs.clear();
        self.Mems.clear();
        self.UID = 0;
        self.GID = 0;
        self.CgroupPath.clear();
        self.DriveExposePolicy = ::protobuf::EnumOrUnknown::new(DriveExposePolicy::COPY);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JailerConfig {
        static instance: JailerConfig = JailerConfig {
            NetNS: ::std::string::String::new(),
            CPUs: ::std::string::String::new(),
            Mems: ::std::string::String::new(),
            UID: 0,
            GID: 0,
            CgroupPath: ::std::string::String::new(),
            DriveExposePolicy: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JailerConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JailerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JailerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JailerConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.UpdateBalloonRequest)
pub struct UpdateBalloonRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.UpdateBalloonRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.UpdateBalloonRequest.AmountMib)
    pub AmountMib: i64,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.UpdateBalloonRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateBalloonRequest {
    fn default() -> &'a UpdateBalloonRequest {
        <UpdateBalloonRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBalloonRequest {
    pub fn new() -> UpdateBalloonRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &UpdateBalloonRequest| { &m.VMID },
            |m: &mut UpdateBalloonRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AmountMib",
            |m: &UpdateBalloonRequest| { &m.AmountMib },
            |m: &mut UpdateBalloonRequest| { &mut m.AmountMib },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateBalloonRequest>(
            "UpdateBalloonRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateBalloonRequest {
    const NAME: &'static str = "UpdateBalloonRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                16 => {
                    self.AmountMib = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if self.AmountMib != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.AmountMib);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if self.AmountMib != 0 {
            os.write_int64(2, self.AmountMib)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateBalloonRequest {
        UpdateBalloonRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.AmountMib = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateBalloonRequest {
        static instance: UpdateBalloonRequest = UpdateBalloonRequest {
            VMID: ::std::string::String::new(),
            AmountMib: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateBalloonRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateBalloonRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateBalloonRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBalloonRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetBalloonConfigRequest)
pub struct GetBalloonConfigRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonConfigRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetBalloonConfigRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBalloonConfigRequest {
    fn default() -> &'a GetBalloonConfigRequest {
        <GetBalloonConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBalloonConfigRequest {
    pub fn new() -> GetBalloonConfigRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &GetBalloonConfigRequest| { &m.VMID },
            |m: &mut GetBalloonConfigRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBalloonConfigRequest>(
            "GetBalloonConfigRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBalloonConfigRequest {
    const NAME: &'static str = "GetBalloonConfigRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBalloonConfigRequest {
        GetBalloonConfigRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBalloonConfigRequest {
        static instance: GetBalloonConfigRequest = GetBalloonConfigRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBalloonConfigRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBalloonConfigRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBalloonConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalloonConfigRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetBalloonConfigResponse)
pub struct GetBalloonConfigResponse {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonConfigResponse.BalloonConfig)
    pub BalloonConfig: ::protobuf::MessageField<super::types::FirecrackerBalloonDevice>,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetBalloonConfigResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBalloonConfigResponse {
    fn default() -> &'a GetBalloonConfigResponse {
        <GetBalloonConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBalloonConfigResponse {
    pub fn new() -> GetBalloonConfigResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::FirecrackerBalloonDevice>(
            "BalloonConfig",
            |m: &GetBalloonConfigResponse| { &m.BalloonConfig },
            |m: &mut GetBalloonConfigResponse| { &mut m.BalloonConfig },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBalloonConfigResponse>(
            "GetBalloonConfigResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBalloonConfigResponse {
    const NAME: &'static str = "GetBalloonConfigResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.BalloonConfig)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.BalloonConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.BalloonConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBalloonConfigResponse {
        GetBalloonConfigResponse::new()
    }

    fn clear(&mut self) {
        self.BalloonConfig.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBalloonConfigResponse {
        static instance: GetBalloonConfigResponse = GetBalloonConfigResponse {
            BalloonConfig: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBalloonConfigResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBalloonConfigResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBalloonConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalloonConfigResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetBalloonStatsRequest)
pub struct GetBalloonStatsRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsRequest.VMID)
    pub VMID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetBalloonStatsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBalloonStatsRequest {
    fn default() -> &'a GetBalloonStatsRequest {
        <GetBalloonStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBalloonStatsRequest {
    pub fn new() -> GetBalloonStatsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &GetBalloonStatsRequest| { &m.VMID },
            |m: &mut GetBalloonStatsRequest| { &mut m.VMID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBalloonStatsRequest>(
            "GetBalloonStatsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBalloonStatsRequest {
    const NAME: &'static str = "GetBalloonStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBalloonStatsRequest {
        GetBalloonStatsRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBalloonStatsRequest {
        static instance: GetBalloonStatsRequest = GetBalloonStatsRequest {
            VMID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBalloonStatsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBalloonStatsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBalloonStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalloonStatsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.GetBalloonStatsResponse)
pub struct GetBalloonStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.ActualMib)
    pub ActualMib: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.ActualPages)
    pub ActualPages: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.AvailableMemory)
    pub AvailableMemory: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.DiskCaches)
    pub DiskCaches: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.FreeMemory)
    pub FreeMemory: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.HugetlbAllocations)
    pub HugetlbAllocations: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.HugetlbFailures)
    pub HugetlbFailures: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.MajorFaults)
    pub MajorFaults: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.MinorFaults)
    pub MinorFaults: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.SwapIn)
    pub SwapIn: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.SwapOut)
    pub SwapOut: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.TargetMib)
    pub TargetMib: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.TargetPages)
    pub TargetPages: i64,
    // @@protoc_insertion_point(field:fc_ctrd.GetBalloonStatsResponse.TotalMemory)
    pub TotalMemory: i64,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.GetBalloonStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBalloonStatsResponse {
    fn default() -> &'a GetBalloonStatsResponse {
        <GetBalloonStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBalloonStatsResponse {
    pub fn new() -> GetBalloonStatsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ActualMib",
            |m: &GetBalloonStatsResponse| { &m.ActualMib },
            |m: &mut GetBalloonStatsResponse| { &mut m.ActualMib },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ActualPages",
            |m: &GetBalloonStatsResponse| { &m.ActualPages },
            |m: &mut GetBalloonStatsResponse| { &mut m.ActualPages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "AvailableMemory",
            |m: &GetBalloonStatsResponse| { &m.AvailableMemory },
            |m: &mut GetBalloonStatsResponse| { &mut m.AvailableMemory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DiskCaches",
            |m: &GetBalloonStatsResponse| { &m.DiskCaches },
            |m: &mut GetBalloonStatsResponse| { &mut m.DiskCaches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FreeMemory",
            |m: &GetBalloonStatsResponse| { &m.FreeMemory },
            |m: &mut GetBalloonStatsResponse| { &mut m.FreeMemory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HugetlbAllocations",
            |m: &GetBalloonStatsResponse| { &m.HugetlbAllocations },
            |m: &mut GetBalloonStatsResponse| { &mut m.HugetlbAllocations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HugetlbFailures",
            |m: &GetBalloonStatsResponse| { &m.HugetlbFailures },
            |m: &mut GetBalloonStatsResponse| { &mut m.HugetlbFailures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MajorFaults",
            |m: &GetBalloonStatsResponse| { &m.MajorFaults },
            |m: &mut GetBalloonStatsResponse| { &mut m.MajorFaults },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MinorFaults",
            |m: &GetBalloonStatsResponse| { &m.MinorFaults },
            |m: &mut GetBalloonStatsResponse| { &mut m.MinorFaults },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SwapIn",
            |m: &GetBalloonStatsResponse| { &m.SwapIn },
            |m: &mut GetBalloonStatsResponse| { &mut m.SwapIn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SwapOut",
            |m: &GetBalloonStatsResponse| { &m.SwapOut },
            |m: &mut GetBalloonStatsResponse| { &mut m.SwapOut },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TargetMib",
            |m: &GetBalloonStatsResponse| { &m.TargetMib },
            |m: &mut GetBalloonStatsResponse| { &mut m.TargetMib },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TargetPages",
            |m: &GetBalloonStatsResponse| { &m.TargetPages },
            |m: &mut GetBalloonStatsResponse| { &mut m.TargetPages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TotalMemory",
            |m: &GetBalloonStatsResponse| { &m.TotalMemory },
            |m: &mut GetBalloonStatsResponse| { &mut m.TotalMemory },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBalloonStatsResponse>(
            "GetBalloonStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBalloonStatsResponse {
    const NAME: &'static str = "GetBalloonStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ActualMib = is.read_int64()?;
                },
                16 => {
                    self.ActualPages = is.read_int64()?;
                },
                24 => {
                    self.AvailableMemory = is.read_int64()?;
                },
                32 => {
                    self.DiskCaches = is.read_int64()?;
                },
                40 => {
                    self.FreeMemory = is.read_int64()?;
                },
                48 => {
                    self.HugetlbAllocations = is.read_int64()?;
                },
                56 => {
                    self.HugetlbFailures = is.read_int64()?;
                },
                64 => {
                    self.MajorFaults = is.read_int64()?;
                },
                72 => {
                    self.MinorFaults = is.read_int64()?;
                },
                80 => {
                    self.SwapIn = is.read_int64()?;
                },
                88 => {
                    self.SwapOut = is.read_int64()?;
                },
                96 => {
                    self.TargetMib = is.read_int64()?;
                },
                104 => {
                    self.TargetPages = is.read_int64()?;
                },
                112 => {
                    self.TotalMemory = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ActualMib != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.ActualMib);
        }
        if self.ActualPages != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.ActualPages);
        }
        if self.AvailableMemory != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.AvailableMemory);
        }
        if self.DiskCaches != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.DiskCaches);
        }
        if self.FreeMemory != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.FreeMemory);
        }
        if self.HugetlbAllocations != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.HugetlbAllocations);
        }
        if self.HugetlbFailures != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.HugetlbFailures);
        }
        if self.MajorFaults != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.MajorFaults);
        }
        if self.MinorFaults != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.MinorFaults);
        }
        if self.SwapIn != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.SwapIn);
        }
        if self.SwapOut != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.SwapOut);
        }
        if self.TargetMib != 0 {
            my_size += ::protobuf::rt::int64_size(12, self.TargetMib);
        }
        if self.TargetPages != 0 {
            my_size += ::protobuf::rt::int64_size(13, self.TargetPages);
        }
        if self.TotalMemory != 0 {
            my_size += ::protobuf::rt::int64_size(14, self.TotalMemory);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ActualMib != 0 {
            os.write_int64(1, self.ActualMib)?;
        }
        if self.ActualPages != 0 {
            os.write_int64(2, self.ActualPages)?;
        }
        if self.AvailableMemory != 0 {
            os.write_int64(3, self.AvailableMemory)?;
        }
        if self.DiskCaches != 0 {
            os.write_int64(4, self.DiskCaches)?;
        }
        if self.FreeMemory != 0 {
            os.write_int64(5, self.FreeMemory)?;
        }
        if self.HugetlbAllocations != 0 {
            os.write_int64(6, self.HugetlbAllocations)?;
        }
        if self.HugetlbFailures != 0 {
            os.write_int64(7, self.HugetlbFailures)?;
        }
        if self.MajorFaults != 0 {
            os.write_int64(8, self.MajorFaults)?;
        }
        if self.MinorFaults != 0 {
            os.write_int64(9, self.MinorFaults)?;
        }
        if self.SwapIn != 0 {
            os.write_int64(10, self.SwapIn)?;
        }
        if self.SwapOut != 0 {
            os.write_int64(11, self.SwapOut)?;
        }
        if self.TargetMib != 0 {
            os.write_int64(12, self.TargetMib)?;
        }
        if self.TargetPages != 0 {
            os.write_int64(13, self.TargetPages)?;
        }
        if self.TotalMemory != 0 {
            os.write_int64(14, self.TotalMemory)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBalloonStatsResponse {
        GetBalloonStatsResponse::new()
    }

    fn clear(&mut self) {
        self.ActualMib = 0;
        self.ActualPages = 0;
        self.AvailableMemory = 0;
        self.DiskCaches = 0;
        self.FreeMemory = 0;
        self.HugetlbAllocations = 0;
        self.HugetlbFailures = 0;
        self.MajorFaults = 0;
        self.MinorFaults = 0;
        self.SwapIn = 0;
        self.SwapOut = 0;
        self.TargetMib = 0;
        self.TargetPages = 0;
        self.TotalMemory = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBalloonStatsResponse {
        static instance: GetBalloonStatsResponse = GetBalloonStatsResponse {
            ActualMib: 0,
            ActualPages: 0,
            AvailableMemory: 0,
            DiskCaches: 0,
            FreeMemory: 0,
            HugetlbAllocations: 0,
            HugetlbFailures: 0,
            MajorFaults: 0,
            MinorFaults: 0,
            SwapIn: 0,
            SwapOut: 0,
            TargetMib: 0,
            TargetPages: 0,
            TotalMemory: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBalloonStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBalloonStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBalloonStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalloonStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:fc_ctrd.UpdateBalloonStatsRequest)
pub struct UpdateBalloonStatsRequest {
    // message fields
    // @@protoc_insertion_point(field:fc_ctrd.UpdateBalloonStatsRequest.VMID)
    pub VMID: ::std::string::String,
    // @@protoc_insertion_point(field:fc_ctrd.UpdateBalloonStatsRequest.StatsPollingIntervals)
    pub StatsPollingIntervals: i64,
    // special fields
    // @@protoc_insertion_point(special_field:fc_ctrd.UpdateBalloonStatsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateBalloonStatsRequest {
    fn default() -> &'a UpdateBalloonStatsRequest {
        <UpdateBalloonStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBalloonStatsRequest {
    pub fn new() -> UpdateBalloonStatsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "VMID",
            |m: &UpdateBalloonStatsRequest| { &m.VMID },
            |m: &mut UpdateBalloonStatsRequest| { &mut m.VMID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StatsPollingIntervals",
            |m: &UpdateBalloonStatsRequest| { &m.StatsPollingIntervals },
            |m: &mut UpdateBalloonStatsRequest| { &mut m.StatsPollingIntervals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateBalloonStatsRequest>(
            "UpdateBalloonStatsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateBalloonStatsRequest {
    const NAME: &'static str = "UpdateBalloonStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.VMID = is.read_string()?;
                },
                16 => {
                    self.StatsPollingIntervals = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.VMID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.VMID);
        }
        if self.StatsPollingIntervals != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.StatsPollingIntervals);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.VMID.is_empty() {
            os.write_string(1, &self.VMID)?;
        }
        if self.StatsPollingIntervals != 0 {
            os.write_int64(2, self.StatsPollingIntervals)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateBalloonStatsRequest {
        UpdateBalloonStatsRequest::new()
    }

    fn clear(&mut self) {
        self.VMID.clear();
        self.StatsPollingIntervals = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateBalloonStatsRequest {
        static instance: UpdateBalloonStatsRequest = UpdateBalloonStatsRequest {
            VMID: ::std::string::String::new(),
            StatsPollingIntervals: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateBalloonStatsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateBalloonStatsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateBalloonStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBalloonStatsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:fc_ctrd.DriveExposePolicy)
pub enum DriveExposePolicy {
    // @@protoc_insertion_point(enum_value:fc_ctrd.DriveExposePolicy.COPY)
    COPY = 0,
    // @@protoc_insertion_point(enum_value:fc_ctrd.DriveExposePolicy.BIND)
    BIND = 1,
}

impl ::protobuf::Enum for DriveExposePolicy {
    const NAME: &'static str = "DriveExposePolicy";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DriveExposePolicy> {
        match value {
            0 => ::std::option::Option::Some(DriveExposePolicy::COPY),
            1 => ::std::option::Option::Some(DriveExposePolicy::BIND),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DriveExposePolicy] = &[
        DriveExposePolicy::COPY,
        DriveExposePolicy::BIND,
    ];
}

impl ::protobuf::EnumFull for DriveExposePolicy {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DriveExposePolicy").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DriveExposePolicy {
    fn default() -> Self {
        DriveExposePolicy::COPY
    }
}

impl DriveExposePolicy {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DriveExposePolicy>("DriveExposePolicy")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11firecracker.proto\x12\x07fc_ctrd\x1a\x0btypes.proto\"\xe8\x05\n\
    \x0fCreateVMRequest\x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12H\n\
    \nMachineCfg\x18\x02\x20\x01(\x0b2(.fc_ctrd.FirecrackerMachineConfigurat\
    ionR\nMachineCfg\x12(\n\x0fKernelImagePath\x18\x03\x20\x01(\tR\x0fKernel\
    ImagePath\x12\x1e\n\nKernelArgs\x18\x04\x20\x01(\tR\nKernelArgs\x12;\n\t\
    RootDrive\x18\x05\x20\x01(\x0b2\x1d.fc_ctrd.FirecrackerRootDriveR\tRootD\
    rive\x12@\n\x0bDriveMounts\x18\x06\x20\x03(\x0b2\x1e.fc_ctrd.Firecracker\
    DriveMountR\x0bDriveMounts\x12R\n\x11NetworkInterfaces\x18\x07\x20\x03(\
    \x0b2$.fc_ctrd.FirecrackerNetworkInterfaceR\x11NetworkInterfaces\x12&\n\
    \x0eContainerCount\x18\x08\x20\x01(\x05R\x0eContainerCount\x12:\n\x18Exi\
    tAfterAllTasksDeleted\x18\t\x20\x01(\x08R\x18ExitAfterAllTasksDeleted\
    \x129\n\x0cJailerConfig\x18\n\x20\x01(\x0b2\x15.fc_ctrd.JailerConfigR\
    \x0cJailerConfig\x12&\n\x0eTimeoutSeconds\x18\x0b\x20\x01(\rR\x0eTimeout\
    Seconds\x12\x20\n\x0bLogFifoPath\x18\x0c\x20\x01(\tR\x0bLogFifoPath\x12(\
    \n\x0fMetricsFifoPath\x18\r\x20\x01(\tR\x0fMetricsFifoPath\x12G\n\rBallo\
    onDevice\x18\x0e\x20\x01(\x0b2!.fc_ctrd.FirecrackerBalloonDeviceR\rBallo\
    onDevice\"\xb2\x01\n\x10CreateVMResponse\x12\x12\n\x04VMID\x18\x01\x20\
    \x01(\tR\x04VMID\x12\x1e\n\nSocketPath\x18\x02\x20\x01(\tR\nSocketPath\
    \x12\x20\n\x0bLogFifoPath\x18\x03\x20\x01(\tR\x0bLogFifoPath\x12(\n\x0fM\
    etricsFifoPath\x18\x04\x20\x01(\tR\x0fMetricsFifoPath\x12\x1e\n\nCgroupP\
    ath\x18\x05\x20\x01(\tR\nCgroupPath\"$\n\x0ePauseVMRequest\x12\x12\n\x04\
    VMID\x18\x01\x20\x01(\tR\x04VMID\"%\n\x0fResumeVMRequest\x12\x12\n\x04VM\
    ID\x18\x01\x20\x01(\tR\x04VMID\"s\n\x17CreateVMSnapshotRequest\x12\x12\n\
    \x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12\"\n\x0cSnapshotPath\x18\x02\x20\
    \x01(\tR\x0cSnapshotPath\x12\x20\n\x0bMemFilePath\x18\x03\x20\x01(\tR\
    \x0bMemFilePath\"\x8d\x01\n\x15LoadVMSnapshotRequest\x12\x12\n\x04VMID\
    \x18\x01\x20\x01(\tR\x04VMID\x12\"\n\x0cSnapshotPath\x18\x02\x20\x01(\tR\
    \x0cSnapshotPath\x12\x20\n\x0bMemFilePath\x18\x03\x20\x01(\tR\x0bMemFile\
    Path\x12\x1a\n\x08ResumeVM\x18\x04\x20\x01(\x08R\x08ResumeVM\"%\n\x0fUnl\
    oadVMRequest\x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\"K\n\rStopVMR\
    equest\x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12&\n\x0eTimeoutSe\
    conds\x18\x02\x20\x01(\rR\x0eTimeoutSeconds\"&\n\x10GetVMInfoRequest\x12\
    \x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\"\xd1\x01\n\x11GetVMInfoRespo\
    nse\x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12\x1e\n\nSocketPath\
    \x18\x02\x20\x01(\tR\nSocketPath\x12\x20\n\x0bLogFifoPath\x18\x03\x20\
    \x01(\tR\x0bLogFifoPath\x12(\n\x0fMetricsFifoPath\x18\x04\x20\x01(\tR\
    \x0fMetricsFifoPath\x12\x1e\n\nCgroupPath\x18\x05\x20\x01(\tR\nCgroupPat\
    h\x12\x1c\n\tVSockPath\x18\x06\x20\x01(\tR\tVSockPath\"F\n\x14SetVMMetad\
    ataRequest\x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12\x1a\n\x08Me\
    tadata\x18\x02\x20\x01(\tR\x08Metadata\"I\n\x17UpdateVMMetadataRequest\
    \x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12\x1a\n\x08Metadata\x18\
    \x02\x20\x01(\tR\x08Metadata\"*\n\x14GetVMMetadataRequest\x12\x12\n\x04V\
    MID\x18\x01\x20\x01(\tR\x04VMID\"3\n\x15GetVMMetadataResponse\x12\x1a\n\
    \x08Metadata\x18\x01\x20\x01(\tR\x08Metadata\"\xda\x01\n\x0cJailerConfig\
    \x12\x14\n\x05NetNS\x18\x01\x20\x01(\tR\x05NetNS\x12\x12\n\x04CPUs\x18\
    \x02\x20\x01(\tR\x04CPUs\x12\x12\n\x04Mems\x18\x03\x20\x01(\tR\x04Mems\
    \x12\x10\n\x03UID\x18\x04\x20\x01(\rR\x03UID\x12\x10\n\x03GID\x18\x05\
    \x20\x01(\rR\x03GID\x12\x1e\n\nCgroupPath\x18\x06\x20\x01(\tR\nCgroupPat\
    h\x12H\n\x11DriveExposePolicy\x18\x07\x20\x01(\x0e2\x1a.fc_ctrd.DriveExp\
    osePolicyR\x11DriveExposePolicy\"H\n\x14UpdateBalloonRequest\x12\x12\n\
    \x04VMID\x18\x01\x20\x01(\tR\x04VMID\x12\x1c\n\tAmountMib\x18\x02\x20\
    \x01(\x03R\tAmountMib\"-\n\x17GetBalloonConfigRequest\x12\x12\n\x04VMID\
    \x18\x01\x20\x01(\tR\x04VMID\"c\n\x18GetBalloonConfigResponse\x12G\n\rBa\
    lloonConfig\x18\x01\x20\x01(\x0b2!.fc_ctrd.FirecrackerBalloonDeviceR\rBa\
    lloonConfig\",\n\x16GetBalloonStatsRequest\x12\x12\n\x04VMID\x18\x01\x20\
    \x01(\tR\x04VMID\"\xf5\x03\n\x17GetBalloonStatsResponse\x12\x1c\n\tActua\
    lMib\x18\x01\x20\x01(\x03R\tActualMib\x12\x20\n\x0bActualPages\x18\x02\
    \x20\x01(\x03R\x0bActualPages\x12(\n\x0fAvailableMemory\x18\x03\x20\x01(\
    \x03R\x0fAvailableMemory\x12\x1e\n\nDiskCaches\x18\x04\x20\x01(\x03R\nDi\
    skCaches\x12\x1e\n\nFreeMemory\x18\x05\x20\x01(\x03R\nFreeMemory\x12.\n\
    \x12HugetlbAllocations\x18\x06\x20\x01(\x03R\x12HugetlbAllocations\x12(\
    \n\x0fHugetlbFailures\x18\x07\x20\x01(\x03R\x0fHugetlbFailures\x12\x20\n\
    \x0bMajorFaults\x18\x08\x20\x01(\x03R\x0bMajorFaults\x12\x20\n\x0bMinorF\
    aults\x18\t\x20\x01(\x03R\x0bMinorFaults\x12\x16\n\x06SwapIn\x18\n\x20\
    \x01(\x03R\x06SwapIn\x12\x18\n\x07SwapOut\x18\x0b\x20\x01(\x03R\x07SwapO\
    ut\x12\x1c\n\tTargetMib\x18\x0c\x20\x01(\x03R\tTargetMib\x12\x20\n\x0bTa\
    rgetPages\x18\r\x20\x01(\x03R\x0bTargetPages\x12\x20\n\x0bTotalMemory\
    \x18\x0e\x20\x01(\x03R\x0bTotalMemory\"e\n\x19UpdateBalloonStatsRequest\
    \x12\x12\n\x04VMID\x18\x01\x20\x01(\tR\x04VMID\x124\n\x15StatsPollingInt\
    ervals\x18\x02\x20\x01(\x03R\x15StatsPollingIntervals*'\n\x11DriveExpose\
    Policy\x12\x08\n\x04COPY\x10\0\x12\x08\n\x04BIND\x10\x01B\x07Z\x05protob\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::types::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(CreateVMRequest::generated_message_descriptor_data());
            messages.push(CreateVMResponse::generated_message_descriptor_data());
            messages.push(PauseVMRequest::generated_message_descriptor_data());
            messages.push(ResumeVMRequest::generated_message_descriptor_data());
            messages.push(CreateVMSnapshotRequest::generated_message_descriptor_data());
            messages.push(LoadVMSnapshotRequest::generated_message_descriptor_data());
            messages.push(UnloadVMRequest::generated_message_descriptor_data());
            messages.push(StopVMRequest::generated_message_descriptor_data());
            messages.push(GetVMInfoRequest::generated_message_descriptor_data());
            messages.push(GetVMInfoResponse::generated_message_descriptor_data());
            messages.push(SetVMMetadataRequest::generated_message_descriptor_data());
            messages.push(UpdateVMMetadataRequest::generated_message_descriptor_data());
            messages.push(GetVMMetadataRequest::generated_message_descriptor_data());
            messages.push(GetVMMetadataResponse::generated_message_descriptor_data());
            messages.push(JailerConfig::generated_message_descriptor_data());
            messages.push(UpdateBalloonRequest::generated_message_descriptor_data());
            messages.push(GetBalloonConfigRequest::generated_message_descriptor_data());
            messages.push(GetBalloonConfigResponse::generated_message_descriptor_data());
            messages.push(GetBalloonStatsRequest::generated_message_descriptor_data());
            messages.push(GetBalloonStatsResponse::generated_message_descriptor_data());
            messages.push(UpdateBalloonStatsRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(DriveExposePolicy::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
